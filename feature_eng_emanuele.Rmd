---
title: "Feature engineering Emanuele"
author: "Emanuele Giona"
date: "21 gennaio 2019"
output: html_document
---

## Features to analyze

Group 1:

- MSSubClass: categorical
- MSZoning: categorical
- Street: ordinal
- Alley: ordinal
- Neighborhood: categorical
- Condition1: categorical
- Condition2: categorical

Group 2:

- LotFrontage: value
- LotArea: value
- LotShape: ordinal
- LandContour: categorical
- LotConfig: categorical
- LandSlope: ordinal

Group 3:

- Utilities: ordinal
- BldgType: categorical
- HouseStyle: categorical
- Heating: categorical
- HeatingQC: ordinal (quality)
- CentralAir: yes/no
- Electrical: categorical
- Fireplaces: value
- FireplacesQu: ordinal (quality)
- MiscFeature: categorical
- MiscVal: value

```{r}
#--- imports ---
library(ggplot2)
library(dplyr)
library(Boruta)

#--- datasets ---
trainingSet <- read.csv("data/train.csv", stringsAsFactors = F)
testSet <- read.csv("data/test.csv", stringsAsFactors = F)

#--- static vars ---
#for subsequent submission on Kaggle
testIDs <- testSet$Id

Group1 <- c("MSSubClass", "MSZoning", "Street", "Alley", "Neighborhood", "Condition1", "Condition2")
Group2 <- c("LotFrontage", "LotArea", "LotShape", "LandContour", "LotConfig", "LandSlope")
Group3 <- c("Utilities", "BldgType", "HouseStyle", "Heating", "HeatingQC", "CentralAir", "Electrical", "Fireplaces", "FireplaceQu", "MiscFeature", "MiscVal")

#ordinal variables
AccessType <- c("None" = 0, "Grvl" = 1, "Pave" = 2)
LotShape <- c("IR3" = 0, "IR2" = 1, "IR1" = 2, "Reg" = 3)
LandSlope <- c("Sev" = 0, "Mod" = 1, "Gtl" = 2)
Utilities <- c("None" = 0, "ELO" = 1, "NoSeWa" = 2, "NoSewr" = 3, "AllPub" = 4)
Quality <- c("None" = 0, "Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5)
CentralAir <- c("N" = 0, "Y" = 1)

#--- preliminary data handling ---
trainingSet$Id <- NULL
testSet$Id <- NULL
testSet$SalePrice <- NA
fullData <- rbind(trainingSet, testSet)

#--- functions ---
#returns the mode of a collection of values, ignoring NAs
getMode <- function(values){
  uniques <- unique(values)
  uniques <- uniques[!is.na(uniques)]
  maxFreqID <- which.max(tabulate(match(values,uniques)))
  uniques[maxFreqID]
}

#returns values as factors, filling NAs with the mode or with the specified argument
getFactors <- function(values, replaceNA = "NA"){
  if(!is.factor(values))
  {
    values[is.na(values)] <- ifelse(replaceNA == "NA", getMode(values), replaceNA)
    values <- as.factor(values)
  }
  values
}

#returns values as integers, enconding them via the given dictionary, filling NAs with the mode or with the specified argument
getIntegers <- function(values, dictionary, replaceNA = "NA"){
  if(!is.integer(values))
  {
    values[is.na(values)] <- ifelse(replaceNA == "NA", getMode(values), replaceNA)
    values <- as.integer(dictionary[values])
  }
  values
}

#returns average frontage given a certain neighborhood
avgFrontage <- function(neighborhood){
  as.integer(mean(fullData$LotFrontage[fullData$Neighborhood == neighborhood], na.rm = T))
}

#substitues all NAs with the average frontage of the same neighborhood
getValidFrontages <- function(data){
  if(0 < length(which(is.na(data$LotFrontage))))
  {
    for(i in 1:nrow(data))
      if(is.na(data$LotFrontage[i]))
        data$LotFrontage[i] <- avgFrontage(data$Neighborhood[i])
  }
  data
}

#fixes incoherent MiscFeature and MiscVal values (MiscFeature = NA <-> MiscVal = 0)
getValidMiscFeaturesAndVal <- function(data){
  if(0 < length(which((is.na(data$MiscFeature) & data$MiscVal > 0) | (!is.na(data$MiscFeature) & data$MiscVal == 0))))
  {
    for(i in 1:nrow(data)){
      if(is.na(data$MiscFeature[i]) & data$MiscVal[i] > 0)
        data$MiscVal[i] <- 0
      else if(!is.na(data$MiscFeature[i]) & data$MiscVal[i] == 0)
        data$MiscFeature[i] <- "None"
    }
  }
  data
}

#returns the most important features, estimated via the Boruta technique; can be set up to only work on selected features (default: all) and to meet a certain importance threshold (default: 0)
applyBoruta <- function(data, features = NULL, threshold = 0){
  set.seed(12345)
  if(!is.null(features)){
    data <- data %>%
      select(., SalePrice, features) %>%
      filter(., !is.na(.$SalePrice))
  }
  
  borutaImp <- Boruta(data$SalePrice~., data = data, doTrace = 0)
  goodFeatures <- getSelectedAttributes(borutaImp)
  stats <- attStats(borutaImp) %>%
    filter(., .$decision == "Confirmed")
  
  stats$feature <- goodFeatures
  stats <- stats %>%
    filter(.$meanImp >= threshold) %>%
    select(., feature, meanImp) %>%
    arrange(.$meanImp)
}
```

```{r}
#Group 1 features

fullData$MSSubClass <- getFactors(fullData$MSSubClass)
fullData$MSZoning <- getFactors(fullData$MSZoning)
fullData$Street <- getIntegers(fullData$Street, AccessType)
fullData$Alley <- getFactors(fullData$Alley, "None")
fullData$Neighborhood <- getFactors(fullData$Neighborhood)
fullData$Condition1 <- getFactors(fullData$Condition1)
fullData$Condition2 <- getFactors(fullData$Condition2)

# tmpData1 <- fullData[Group1]
# tmpData1$SalePrice <- fullData$SalePrice
# ggplot(data = tmpData1[!is.na(tmpData1$SalePrice),], aes(x = MSSubClass, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = tmpData1[!is.na(tmpData1$SalePrice),], aes(x = MSZoning, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = tmpData1[!is.na(tmpData1$SalePrice),], aes(x = Street, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = tmpData1[!is.na(tmpData1$SalePrice),], aes(x = Alley, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = tmpData1[!is.na(tmpData1$SalePrice),], aes(x = Neighborhood, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = tmpData1[!is.na(tmpData1$SalePrice),], aes(x = Condition1, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = tmpData1[!is.na(tmpData1$SalePrice),], aes(x = Condition2, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
```

```{r}
print(applyBoruta(fullData, Group1, 0))
```

The street being Gravel or Paved seems to greatly influence SalePrice.

Condition1 and Condition2 look suspiciously related to each other.

The Boruta technique drops Street and Condition2 completely, while giving importance to the following features in descending order:

- Neighborhood (67%)
- MSSubClass (50%)
- MSZoning (41%)
- Condition1 (21%)
- Alley (18%)

```{r}
#Group 2 features

fullData <- getValidFrontages(fullData)
fullData$LotShape <- getIntegers(fullData$LotShape, LotShape)
fullData$LandContour <- getFactors(fullData$LandContour)
fullData$LotConfig <- getFactors(fullData$LotConfig)
fullData$LandSlope <- getIntegers(fullData$LandSlope, LandSlope)

# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = LotFrontage, y = SalePrice)) +
#   geom_point(color = "blue", size = 1) +
#   geom_smooth(method = "lm", se = F, color = "red")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice) & fullData$LotFrontage < 200 & fullData$LotArea < 100000 & fullData$SalePrice < 600000,], aes(x = LotFrontage, y = SalePrice)) +
#   geom_point(color = "blue", size = 1) +
#   geom_smooth(method = "lm", se = F, color = "red")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = LotArea, y = SalePrice)) +
#   geom_point(color = "blue", size = 1) +
#   geom_smooth(method = "lm", se = F, color = "red") 
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice) & fullData$LotFrontage < 200 & fullData$LotArea < 100000 & fullData$SalePrice < 600000,], aes(x = LotArea, y = SalePrice)) +
#   geom_point(color = "blue", size = 1) +
#   geom_smooth(method = "lm", se = F, color = "red") 

# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = LotShape, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = LandContour, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = LotConfig, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = LandSlope, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
```

```{r}
print(applyBoruta(fullData, Group2, 0))
```


The following outliers could be removed in order to help the performance of our model:

- 2 houses with LotFrontage value greater than 200 feet
- 4 houses with LotArea greater than 100000 squared feet
- 4 houses with SalePrice greater than 600000 dollars

The Boruta technique returns the following importance scores:

- LotArea (36%)
- LotFrontage (35%)
- LotShape (18%)
- LandContour (12%)
- LotConfig (7%)
- LandSlope (6%)

```{r}
#Group 3 features

fullData$Utilities <- getIntegers(fullData$Utilities, Utilities, "None")
fullData$BldgType <- getFactors(fullData$BldgType)
fullData$HouseStyle <- getFactors(fullData$HouseStyle)
fullData$Heating <- getFactors(fullData$Heating)
fullData$HeatingQC <- getIntegers(fullData$HeatingQC, Quality, 'None')
fullData$CentralAir <- getIntegers(fullData$CentralAir, CentralAir, 'N')
fullData$Electrical <- getFactors(fullData$Electrical)
fullData$FireplaceQu <- getIntegers(fullData$FireplaceQu, Quality, "None")
fullData <- getValidMiscFeaturesAndVal(fullData)
fullData$MiscFeature <- getFactors(fullData$MiscFeature, "None")

# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = Utilities, y = SalePrice)) +
#   geom_point(color = "blue", size = 1) +
#   geom_smooth(method = "lm", se = F, color = "red")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = BldgType, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = HouseStyle, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = Heating, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = HeatingQC, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = CentralAir, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = Electrical, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = Fireplaces, y = SalePrice)) +
#   geom_point(color = "blue", size = 1) +
#   geom_smooth(method = "lm", se = F, color = "red")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice) & fullData$Fireplaces < 3,], aes(x = Fireplaces, y = SalePrice)) +
#   geom_point(color = "blue", size = 1) +
#   geom_smooth(method = "lm", se = F, color = "red")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = FireplaceQu, y = SalePrice)) +
#   geom_bar(stat = "summary", fun.y = "median", fill = "blue")
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = MiscFeature, y = SalePrice)) +
#   geom_point(color = "blue", size = 1)
# 
# tmpData3 <- fullData[!is.na(fullData$SalePrice) & (fullData$MiscFeature == "TenC" | fullData$MiscFeature == "Othr" | fullData$MiscFeature == "Gar2"),]
# print(select(tmpData3, SalePrice, MiscFeature, MiscVal))
# 
# ggplot(data = fullData[!is.na(fullData$SalePrice),], aes(x = MiscVal, y = SalePrice)) +
#   geom_point(color = "blue", size = 1) +
#   geom_smooth(method = "lm", se = F, color = "red")

```

```{r}
print(applyBoruta(fullData, Group3, 0))
```


More outliers have been spotted:

- 1 house with NoSeWa utilities
- 5 houses with 3 fireplaces
- 1 house with the tennis court, 2 houses with a second garage, 1 house with other features
- 2 houses with MiscVal greater than 5000 dollars (these same houses are removed if the previous outliers are removed)

In general, Utilities doesn't look like a good predictor, since all the house but one have AllPub utilities.

Neither MiscVal can be considered as a strong predictor: few houses have MiscVal at most 2500 dollars, given the high rate of houses with no additional features, the value 0 for MiscVal is the most common.

The Boruta technique in fact drops Utilities and assigns very low scores to both MiscVal and MiscFeature, returning the following importance scores:

- HeatingQC (55%)
- FirePlaceQu (37%)
- Electrical (28%)
- HouseStyle (27%)
- CentralAir (22%)
- BldgType (21%)
- Fireplaces (18%)
- Heating (6.3%)
- MiscVal (6%)
- MiscFeature (5.7%)

My suggestion would be to keep all the features that have an importance score greater than 20%, meaning that they can be quite strong predictors.
